{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"The Nim Neon Genesis Evolution [Phase Three]","text":"<p>Here is a compiler guide following instructions from the RFC.</p> <p>It is a draft; read at your own risk.</p> <p>All Rights Reversed</p>"},{"location":"concatenate/","title":"Is it efficient to use <code>&amp;</code> function to concatenate multiple strings","text":"<p><code>&amp;</code> function is a magic proc used to concatenate strings and chars. The Nim compiler does some optimizations to make it perform as good as the in-place version.</p> <p>There are four overloads for <code>&amp;</code> function in the system module.</p> <pre><code>proc `&amp;`*(x: string, y: char): string {.magic: \"ConStrStr\", noSideEffect.}\nproc `&amp;`*(x, y: char): string {.magic: \"ConStrStr\", noSideEffect.}\nproc `&amp;`*(x, y: string): string {.magic: \"ConStrStr\", noSideEffect.}\nproc `&amp;`*(x: char, y: string): string {.magic: \"ConStrStr\", noSideEffect.}\n</code></pre> <p>All of them have the same magic <code>mConStrStr</code>, which is needed in the optimization phases. </p> <pre><code>s = \"Hello \" &amp; name &amp; \", how do you feel\" &amp; 'z'\n</code></pre> <p>Here is the ast of the right-side expression:</p> <pre><code>StmtList\n  Infix\n    Ident \"&amp;\"\n    Infix\n      Ident \"&amp;\"\n      Infix\n        Ident \"&amp;\"\n        StrLit \"Hello \"\n        Ident \"name\"\n      StrLit \", how do you feel\"\n    CharLit 122\n</code></pre> <p>There are lots of <code>&amp;</code> call in the ast, which causes unnecessary overheads. They can be eliminated by lifting the leaf nodes like strings and chars to the same level as the first <code>&amp;</code> ident. </p> <p>Here is the pseudo code: <pre><code>proc traverseConcatTree(result: PNode, x: PNode) =\n  if x.hasMagic(mConStrStr):\n    for i in 1 ..&lt; x.len: # x[0] is the ident \"&amp;\"\n      result.add traverseConcatTree(x[i])\n  else:\n    result.add copyTree(x)\n</code></pre></p> <p>After the transforming, the ast tree becomes now flatten:</p> <pre><code>StmtList\n  Infix\n    Ident \"&amp;\"\n    StrLit \"Hello \"\n    Ident \"name\"\n    StrLit \", how do you feel\"\n    CharLit 122\n</code></pre> <p>There are some adjacent constant expressions which can be merged into a single expression</p> <pre><code>StmtList\n  Infix\n    Ident \"&amp;\"\n    StrLit \"Hello \"\n    Ident \"name\"\n    StrLit \", how do you feelz\"\n</code></pre> <p>So the expression becomes <code>&amp;</code>(\"Hello \", name, \", how do you feelz\"). If all of the parameters are constant expressions, the Infix call can be eliminated.</p> <p>Above should concludes all the transforms in the optimization phases. Now comes the codegen phase. First, the compiler needs to preallocate the memory used by strings. Then <code>appendString</code> adds the value of string literals and identifiers to <code>tmp0</code>. Finally, it assigns the value of <code>tmp0</code> to <code>s</code>.</p> <pre><code>string tmp0;\nstring s;\nstring name;\n...\ntmp0 = rawNewString(6 + 18 + name.len + 1);\n// we cannot generate s = rawNewString(...) here, because\n// ``s`` may be used on the right side of the expression\nappendString(tmp0, strlit_1);\nappendString(tmp0, name);\nappendString(tmp0, strlit_2);\nasgn(s, tmp0);\n</code></pre>"}]}